#!/usr/bin/env python
"""
Alpaca Paper Trading Integration for Cryptocurrency Trading Signals

This script connects to Alpaca's paper trading API and executes trades based on
signals generated by the crypto_trading_signals.py module. It allows for testing
trading strategies without using real money.
"""

import os
import sys
import time
import json
import logging
import argparse
from datetime import datetime, timedelta
import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional

# Import Alpaca API
from alpaca.trading.client import TradingClient
from alpaca.trading.requests import MarketOrderRequest, LimitOrderRequest
from alpaca.trading.enums import OrderSide, TimeInForce
from alpaca.data.historical import CryptoHistoricalDataClient
from alpaca.data.requests import CryptoBarsRequest
from alpaca.data.timeframe import TimeFrame

# Import our modules
from crypto_trading_signals import CryptoDataFetcher, SignalGenerator, Timer

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s.%(msecs)03d - %(name)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
    filename='alpaca_paper_trading.log'
)
logger = logging.getLogger("alpaca_paper_trader")

# Add console handler
console = logging.StreamHandler()
console.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
console.setFormatter(formatter)
logger.addHandler(console)

class AlpacaPaperTrader:
    """
    Class to execute paper trades on Alpaca based on trading signals
    """
    
    def __init__(self, api_key: str = None, api_secret: str = None, base_url: str = "https://paper-api.alpaca.markets"):
        """
        Initialize the AlpacaPaperTrader
        
        Args:
            api_key: Alpaca API key (if None, will look for ALPACA_API_KEY env var)
            api_secret: Alpaca API secret (if None, will look for ALPACA_API_SECRET env var)
            base_url: Alpaca API base URL
        """
        with Timer("AlpacaPaperTrader initialization"):
            # Get API credentials from environment variables if not provided
            self.api_key = api_key or os.environ.get("ALPACA_API_KEY")
            self.api_secret = api_secret or os.environ.get("ALPACA_API_SECRET")
            
            if not self.api_key or not self.api_secret:
                raise ValueError("Alpaca API key and secret must be provided or set as environment variables")
            
            # Initialize Alpaca clients
            self.trading_client = TradingClient(self.api_key, self.api_secret, paper=True)
            self.data_client = CryptoHistoricalDataClient()
            
            # Initialize our signal generator
            self.signal_generator = SignalGenerator()
            
            # Store account info
            self.account = self.trading_client.get_account()
            logger.info(f"Connected to Alpaca paper trading account: {self.account.id}")
            logger.info(f"Account cash: ${float(self.account.cash):.2f}")
            logger.info(f"Account equity: ${float(self.account.equity):.2f}")
            
            # Map of coin IDs to Alpaca symbols
            self.coin_to_symbol = {
                "bitcoin": "BTCUSD",
                "ethereum": "ETHUSD",
                "solana": "SOLUSD",
                "cardano": "ADAUSD",
                "dogecoin": "DOGEUSD",
                "polkadot": "DOTUSD",
                "avalanche-2": "AVAXUSD",
                "chainlink": "LINKUSD",
                "polygon": "MATICUSD",
                "litecoin": "LTCUSD",
                "uniswap": "UNIUSD",
                "stellar": "XLMUSD",
                "cosmos": "ATOMUSD",
                "algorand": "ALGOUSD",
                "tezos": "XTZUSD"
            }
            
            # Reverse mapping
            self.symbol_to_coin = {v: k for k, v in self.coin_to_symbol.items()}
            
            # Track positions and orders
            self.positions = {}
            self.update_positions()
    
    def update_positions(self):
        """
        Update the current positions
        """
        with Timer("Updating positions"):
            positions = self.trading_client.get_all_positions()
            self.positions = {}
            
            for position in positions:
                symbol = position.symbol
                if symbol in self.symbol_to_coin:
                    coin_id = self.symbol_to_coin[symbol]
                    self.positions[coin_id] = {
                        "symbol": symbol,
                        "qty": float(position.qty),
                        "market_value": float(position.market_value),
                        "avg_entry_price": float(position.avg_entry_price),
                        "unrealized_pl": float(position.unrealized_pl),
                        "unrealized_plpc": float(position.unrealized_plpc),
                        "current_price": float(position.current_price)
                    }
            
            logger.info(f"Current positions: {len(self.positions)}")
            for coin_id, position in self.positions.items():
                logger.info(f"  {coin_id}: {position['qty']} @ ${position['avg_entry_price']:.2f} (${position['market_value']:.2f})")
    
    def get_historical_data(self, symbols: List[str], timeframe: TimeFrame = TimeFrame.Day, limit: int = 100) -> Dict[str, pd.DataFrame]:
        """
        Get historical price data from Alpaca
        
        Args:
            symbols: List of Alpaca symbols to fetch data for
            timeframe: Timeframe for the data
            limit: Maximum number of bars to fetch
            
        Returns:
            Dictionary mapping symbols to DataFrames with historical data
        """
        with Timer(f"Getting historical data for {len(symbols)} symbols"):
            historical_data = {}
            
            for symbol in symbols:
                request_params = CryptoBarsRequest(
                    symbol_or_symbols=symbol,
                    timeframe=timeframe,
                    limit=limit
                )
                
                try:
                    bars = self.data_client.get_crypto_bars(request_params)
                    if bars and hasattr(bars, "df") and not bars.df.empty:
                        historical_data[symbol] = bars.df
                        logger.info(f"Got {len(bars.df)} bars for {symbol}")
                    else:
                        logger.warning(f"No data returned for {symbol}")
                except Exception as e:
                    logger.error(f"Error getting historical data for {symbol}: {e}")
            
            return historical_data
    
    def format_data_for_analysis(self, historical_data: Dict[str, pd.DataFrame]) -> Dict[str, np.ndarray]:
        """
        Format the historical data for analysis with our signal generator
        
        Args:
            historical_data: Dictionary mapping symbols to DataFrames with historical data
            
        Returns:
            Dictionary mapping coin IDs to price arrays
        """
        with Timer("Formatting data for analysis"):
            formatted_data = {}
            
            for symbol, df in historical_data.items():
                if symbol in self.symbol_to_coin:
                    coin_id = self.symbol_to_coin[symbol]
                    # Extract close prices and convert to numpy array
                    prices = df['close'].values.astype(np.float32)
                    formatted_data[coin_id] = prices
                    logger.info(f"Formatted {len(prices)} prices for {coin_id}")
            
            return formatted_data
    
    def generate_signals(self, historical_data: Dict[str, np.ndarray]) -> Dict[str, Dict[str, Any]]:
        """
        Generate trading signals based on historical data
        
        Args:
            historical_data: Dictionary mapping coin IDs to price arrays
            
        Returns:
            Dictionary mapping coin IDs to signal dictionaries
        """
        with Timer("Generating signals"):
            # Format data for the signal generator
            coins = list(historical_data.keys())
            
            # Create a 2D array with shape (days, assets)
            min_length = min(len(prices) for prices in historical_data.values())
            prices_array = np.zeros((min_length, len(coins)), dtype=np.float32)
            
            for i, coin_id in enumerate(coins):
                prices_array[:, i] = historical_data[coin_id][-min_length:]
            
            # Generate signals
            signals = self.signal_generator.generate_signals(prices_array, coins)
            
            return signals
    
    def execute_trades(self, signals: Dict[str, Dict[str, Any]], max_position_value: float = 1000.0, max_positions: int = 3):
        """
        Execute trades based on signals
        
        Args:
            signals: Dictionary mapping coin IDs to signal dictionaries
            max_position_value: Maximum value per position in USD
            max_positions: Maximum number of positions to hold at once
        """
        with Timer("Executing trades"):
            # Update positions first
            self.update_positions()
            
            # Get account info
            account = self.trading_client.get_account()
            buying_power = float(account.buying_power)
            logger.info(f"Account buying power: ${buying_power:.2f}")
            
            # Sort signals by confidence
            sorted_signals = sorted(
                [(coin_id, data) for coin_id, data in signals.items()],
                key=lambda x: x[1]["confidence"],
                reverse=True
            )
            
            # Process sell signals first
            for coin_id, signal_data in sorted_signals:
                if coin_id in self.positions and signal_data["final_signal"] == "SELL":
                    symbol = self.coin_to_symbol.get(coin_id)
                    if not symbol:
                        logger.warning(f"No symbol mapping for {coin_id}, skipping")
                        continue
                    
                    position = self.positions[coin_id]
                    qty = position["qty"]
                    
                    logger.info(f"SELL signal for {coin_id} with confidence {signal_data['confidence']:.2f}")
                    logger.info(f"Selling {qty} {symbol} at market price")
                    
                    try:
                        # Create market sell order
                        market_order_data = MarketOrderRequest(
                            symbol=symbol,
                            qty=qty,
                            side=OrderSide.SELL,
                            time_in_force=TimeInForce.GTC
                        )
                        
                        # Submit order
                        market_order = self.trading_client.submit_order(
                            order_data=market_order_data
                        )
                        
                        logger.info(f"Sell order submitted: {market_order.id}")
                    except Exception as e:
                        logger.error(f"Error submitting sell order for {symbol}: {e}")
            
            # Update positions after sells
            self.update_positions()
            
            # Process buy signals if we have room for more positions
            current_positions = len(self.positions)
            positions_to_add = max_positions - current_positions
            
            if positions_to_add <= 0:
                logger.info(f"Already at maximum positions ({max_positions}), not adding more")
                return
            
            # Update account info after sells
            account = self.trading_client.get_account()
            buying_power = float(account.buying_power)
            
            # Calculate value per position
            value_per_position = min(max_position_value, buying_power / positions_to_add)
            logger.info(f"Can add {positions_to_add} positions with ${value_per_position:.2f} each")
            
            # Process buy signals
            positions_added = 0
            for coin_id, signal_data in sorted_signals:
                if positions_added >= positions_to_add:
                    break
                    
                if coin_id not in self.positions and signal_data["final_signal"] == "BUY":
                    symbol = self.coin_to_symbol.get(coin_id)
                    if not symbol:
                        logger.warning(f"No symbol mapping for {coin_id}, skipping")
                        continue
                    
                    current_price = signal_data["price"]
                    qty = value_per_position / current_price
                    
                    # Round to appropriate precision
                    if current_price > 1000:  # BTC
                        qty = round(qty, 6)
                    elif current_price > 100:  # ETH
                        qty = round(qty, 5)
                    else:
                        qty = round(qty, 2)
                    
                    logger.info(f"BUY signal for {coin_id} with confidence {signal_data['confidence']:.2f}")
                    logger.info(f"Buying {qty} {symbol} at market price (approx ${qty * current_price:.2f})")
                    
                    try:
                        # Create market buy order
                        market_order_data = MarketOrderRequest(
                            symbol=symbol,
                            qty=qty,
                            side=OrderSide.BUY,
                            time_in_force=TimeInForce.GTC
                        )
                        
                        # Submit order
                        market_order = self.trading_client.submit_order(
                            order_data=market_order_data
                        )
                        
                        logger.info(f"Buy order submitted: {market_order.id}")
                        positions_added += 1
                    except Exception as e:
                        logger.error(f"Error submitting buy order for {symbol}: {e}")
            
            # Update positions after buys
            self.update_positions()
    
    def run_trading_cycle(self, symbols_to_trade: List[str] = None, max_position_value: float = 1000.0, max_positions: int = 3):
        """
        Run a complete trading cycle: fetch data, generate signals, execute trades
        
        Args:
            symbols_to_trade: List of Alpaca symbols to trade (if None, will use default mappings)
            max_position_value: Maximum value per position in USD
            max_positions: Maximum number of positions to hold at once
        """
        with Timer("Complete trading cycle"):
            # If no symbols provided, use our default mappings
            if not symbols_to_trade:
                symbols_to_trade = list(self.symbol_to_coin.keys())
                # Limit to top 10 to avoid API rate limits
                symbols_to_trade = symbols_to_trade[:10]
            
            logger.info(f"Starting trading cycle for {len(symbols_to_trade)} symbols")
            
            # Get historical data
            historical_data = self.get_historical_data(symbols_to_trade)
            
            if not historical_data:
                logger.error("No historical data available, aborting trading cycle")
                return
            
            # Format data for analysis
            formatted_data = self.format_data_for_analysis(historical_data)
            
            if not formatted_data:
                logger.error("Failed to format data for analysis, aborting trading cycle")
                return
            
            # Generate signals
            signals = self.generate_signals(formatted_data)
            
            if not signals:
                logger.error("No signals generated, aborting trading cycle")
                return
            
            # Print signals
            logger.info("Trading signals generated:")
            for coin_id, signal_data in signals.items():
                logger.info(f"{coin_id.upper()}: {signal_data['final_signal']} (Confidence: {signal_data['confidence']:.2f})")
                logger.info(f"  Price: ${signal_data['price']:.2f}")
                logger.info(f"  RSI: {signal_data['rsi']:.2f} ({signal_data['rsi_signal']})")
                logger.info(f"  MACD: {signal_data['macd']:.6f} vs Signal: {signal_data['signal_line']:.6f} ({signal_data['macd_signal']})")
                logger.info(f"  Bollinger Bands: {signal_data['lower_band']:.2f} < {signal_data['middle_band']:.2f} < {signal_data['upper_band']:.2f} ({signal_data['bb_signal']})")
                logger.info(f"  Risk Signal: {signal_data['risk_signal']}")
                logger.info("")
            
            # Execute trades based on signals
            self.execute_trades(signals, max_position_value, max_positions)
            
            # Save signals to file
            output = {
                "timestamp": datetime.now().isoformat(),
                "signals": signals
            }
            
            with open("alpaca_trading_signals.json", "w") as f:
                json.dump(output, f, indent=2)
            
            logger.info("Signals saved to alpaca_trading_signals.json")


def parse_arguments():
    """
    Parse command line arguments
    
    Returns:
        Parsed arguments
    """
    parser = argparse.ArgumentParser(description="Alpaca Paper Trading for Cryptocurrency Trading Signals")
    
    parser.add_argument("--api-key", type=str,
                        help="Alpaca API key (if not provided, will use ALPACA_API_KEY env var)")
    
    parser.add_argument("--api-secret", type=str,
                        help="Alpaca API secret (if not provided, will use ALPACA_API_SECRET env var)")
    
    parser.add_argument("--max-position-value", type=float, default=1000.0,
                        help="Maximum value per position in USD (default: 1000.0)")
    
    parser.add_argument("--max-positions", type=int, default=3,
                        help="Maximum number of positions to hold at once (default: 3)")
    
    parser.add_argument("--symbols", type=str, nargs="+",
                        help="Specific symbols to trade (e.g., BTCUSD ETHUSD)")
    
    parser.add_argument("--interval", type=int, default=60,
                        help="Interval between trading cycles in seconds (reduced from 3600)")
    
    parser.add_argument("--cycles", type=int, default=1,
                        help="Number of trading cycles to run (default: 1, 0 for infinite)")
    
    return parser.parse_args()


def main():
    """
    Main function
    """
    start_time = time.time()
    logger.info(f"Starting Alpaca paper trading at {datetime.now().isoformat()}")
    
    args = parse_arguments()
    
    try:
        # Initialize the paper trader
        paper_trader = AlpacaPaperTrader(
            api_key=args.api_key,
            api_secret=args.api_secret
        )
        
        # Run trading cycles
        cycle_count = 0
        while args.cycles == 0 or cycle_count < args.cycles:
            cycle_count += 1
            logger.info(f"Starting trading cycle {cycle_count}")
            
            paper_trader.run_trading_cycle(
                symbols_to_trade=args.symbols,
                max_position_value=args.max_position_value,
                max_positions=args.max_positions
            )
            
            if args.cycles == 0 or cycle_count < args.cycles:
                next_cycle_time = datetime.now() + timedelta(seconds=args.interval)
                logger.info(f"Waiting for next cycle at {next_cycle_time.strftime('%Y-%m-%d %H:%M:%S')}")
                time.sleep(args.interval)
        
    except KeyboardInterrupt:
        logger.info("Trading interrupted by user")
    except Exception as e:
        logger.error(f"Error in main loop: {e}", exc_info=True)
    
    # Log total execution time
    end_time = time.time()
    total_time = end_time - start_time
    logger.info(f"Total execution time: {total_time:.3f}s ({int(total_time * 1000)}ms)")


if __name__ == "__main__":
    main() 